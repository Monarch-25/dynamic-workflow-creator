{
  "constraints": null,
  "description": "Build a shell command workflow that requires user confirmation and allows modify or skip.",
  "edges": [
    {
      "condition": null,
      "source": "task_1",
      "target": "synthesize"
    }
  ],
  "inputs": [
    {
      "data_type": "string",
      "default": null,
      "description": "Primary user question or request.",
      "id": "query",
      "name": "query",
      "required": false
    }
  ],
  "metadata": {
    "approved_plan": "1. Parse requirements and lock the current task description in shared memory.\n2. Split the task into independent subtasks for tool construction.\n3. Build one tool function per subtask via tool-builder agents.\n4. Verify each tool in a venv with execution-based integrity checks.\n5. Iterate tool fixes until verifier passes or fallback tool is selected.\n6. Assemble a LangGraph workflow that runs subtasks and synthesizes results.\n7. Emit workflow folder with workflow.py, tools.py, README.md, and memory snapshot.\n8. Validate generated code and return user run instructions.",
    "architecture_mode": "subtask_tool_arsenal",
    "cost_estimate": {
      "estimated_input_tokens": 50,
      "estimated_output_tokens": 1024,
      "estimated_total_usd": 0.01551,
      "llm_steps": 1
    },
    "current_task_description": "User Requirements:\nBuild a shell command workflow that requires user confirmation and allows modify or skip.\n\nApproved Plan:\n1. Parse requirements and lock the current task description in shared memory.\n2. Split the task into independent subtasks for tool construction.\n3. Build one tool function per subtask via tool-builder agents.\n4. Verify each tool in a venv with execution-based integrity checks.\n5. Iterate tool fixes until verifier passes or fallback tool is selected.\n6. Assemble a LangGraph workflow that runs subtasks and synthesizes results.\n7. Emit workflow folder with workflow.py, tools.py, README.md, and memory snapshot.\n8. Validate generated code and return user run instructions.\n\nIntent Summary:\nBuild a general-purpose workflow generator from natural language requirements. User context: Build a shell command workflow that requires user confirmation and allows modify or skip. Execution path: 1. Parse requirements and lock the current task description in shared memory. 2. Split the task into independent subtasks for tool construction. 3. Build one tool function per subtask via tool-builder agents. 4. Verify each tool in a venv with execution-based integrity checks. 5. Iterate tool fix...\n",
    "dependency": {
      "roots": [
        "task_1"
      ],
      "sinks": [
        "synthesize"
      ],
      "topological_order": [
        "task_1",
        "synthesize"
      ]
    },
    "intent_summary": "Build a general-purpose workflow generator from natural language requirements. User context: Build a shell command workflow that requires user confirmation and allows modify or skip. Execution path: 1. Parse requirements and lock the current task description in shared memory. 2. Split the task into independent subtasks for tool construction. 3. Build one tool function per subtask via tool-builder agents. 4. Verify each tool in a venv with execution-based integrity checks. 5. Iterate tool fix...",
    "optimization_trace": [
      "validate",
      "normalize",
      "dependency_resolve",
      "dead_step_elimination",
      "merge_compatible_steps",
      "parallelization",
      "retry_policy_injection",
      "cost_estimation"
    ],
    "subtasks": [
      {
        "description": "Build a shell command workflow that requires user confirmation and allows modify or skip",
        "id": "task_1",
        "tool_name": "tool_task_1"
      }
    ],
    "synthesis_prompt": "You are the synthesis head. Combine independent subtask outputs into one clear, direct plain-text answer for the user. Keep the answer coherent with the approved plan and user intent. Avoid JSON output.",
    "tool_functions": {
      "tool_task_1": {
        "code": "import json\nfrom typing import Any, Dict\n\ndef tool_task_1(task_input: Dict[str, Any]) -> Dict[str, Any]:\n    raw_command = task_input.get(\"command\") or task_input.get(\"query\") or \"\"\n    command = str(raw_command).strip()\n    if not command:\n        return {\n            \"tool\": \"tool_task_1\",\n            \"status\": \"ok\",\n            \"result\": json.dumps({\n                \"error\": \"Missing command. Pass task_input['command'].\",\n                \"output\": \"\",\n            }, sort_keys=True),\n        }\n\n    user_message = task_input.get(\"user_message\") or task_input.get(\"approval\") or \"\"\n    user_message = str(user_message).strip() or None\n\n    output = safe_cli(command, user_message=user_message)\n    payload = {\n        \"command\": command,\n        \"user_message\": user_message or \"\",\n        \"output\": output,\n    }\n    return {\n        \"tool\": \"tool_task_1\",\n        \"status\": \"ok\",\n        \"result\": json.dumps(payload, sort_keys=True),\n    }\n",
        "description": "Build a shell command workflow that requires user confirmation and allows modify or skip"
      }
    }
  },
  "name": "shell_registry_smoke2",
  "outputs": [
    {
      "data_type": "string",
      "description": "Final plain-text answer.",
      "id": "final_answer",
      "name": "final_answer",
      "source_step": "synthesize"
    }
  ],
  "steps": [
    {
      "config": {
        "max_output_tokens": 1024,
        "model": "us.anthropic.claude-sonnet-4-20250514-v1:0",
        "prompt": "You are the synthesis head. Combine independent subtask outputs into one clear, direct plain-text answer for the user. Keep the answer coherent with the approved plan and user intent. Avoid JSON output.",
        "temperature": 0
      },
      "id": "synthesize",
      "retry_policy": {
        "backoff_strategy": "exponential",
        "initial_delay_seconds": 1.0,
        "max_delay_seconds": 30.0,
        "max_retries": 2
      },
      "timeout_seconds": 120,
      "type": "llm"
    },
    {
      "config": {
        "subtask_description": "Build a shell command workflow that requires user confirmation and allows modify or skip",
        "tool_name": "tool_task_1"
      },
      "id": "task_1",
      "retry_policy": {
        "backoff_strategy": "exponential",
        "initial_delay_seconds": 1.0,
        "max_delay_seconds": 30.0,
        "max_retries": 2
      },
      "timeout_seconds": 120,
      "type": "tool"
    }
  ],
  "version": "1.0.0"
}